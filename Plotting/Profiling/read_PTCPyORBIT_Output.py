#!/usr/bin/python
# Reads the output generated by PTC-PyORBIT when using Hannes Bartosik's
# output dictionary (outputs the time of each turn)

import matplotlib.pyplot as plt
# ~ from matplotlib.patches import Patch
# ~ from matplotlib.ticker import FormatStrFormatter
# ~ from matplotlib.lines import Line2D
import numpy as np
# ~ import scipy.io as sio 
import os
import sys

def second_convertor(raw_time):
	hour = int(raw_time.split(':')[0])
	minute = int(raw_time.split(':')[1])
	second = int(raw_time.split(':')[2])
	
	return int((hour*3600) + (minute*60) + (second))
	
def calculate_time_steps(raw_time, raw_date):
	
	if len(raw_time) != len(raw_date):
		print 'ERROR: Function calculate_time_steps: Length of raw time and raw date arrays are not equal. EXITING'
		sys.exit()
	
	start_time = raw_time[0]
	start_date = raw_date[0]
	start_time_seconds = second_convertor(start_time)
	turn_time_s=[]
	
	print '\ncalculate_time_steps: simulation started at %s %s\nwhich is %i seconds' % (start_date, start_time, start_time_seconds)
	
	# ~ for i in range(0, len(raw_time), 1):
	for i in range(len(raw_time)-1):
		# Check that we haven't gone past midnight
		if i == 0:
			turn_time_s.append( int( start_time_seconds - second_convertor(raw_time[i]) ) )		
		elif i != len(raw_time):
			if raw_date[i+1] != raw_date[i]: # Changed days
				turn_time_s.append( int( (86400 - second_convertor(raw_time[i])) + second_convertor(raw_time[i+1]) ) )
			else:	# Haven't changed days
				turn_time_s.append( int( second_convertor(raw_time[i+1]) - second_convertor(raw_time[i]) ) )
	return turn_time_s			
	
		

# Parse arguments from command line
from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("-f", "--file", dest="filename",
					help="Input filename, this is the raw output from a PTC-PyORBIT run, note that Hannes Bartosik's output dictionary is required, as well as a turn by turn output.update()", metavar="FILE")

parser.add_argument("-c", "--cores", dest="cores", metavar="CORES", type=int,
					help="Number of CPU cores used for simulation, must be an integer")

parser.add_argument("-n", "--nodes", dest="nodes", metavar="NODES", type=int,
					help="Number of nodes used for simulation, must be an integer")
					
parser.add_argument("-t", "--threads", dest="total_threads", metavar="THREADS", type=int,
					help="Number of threads used for simulation, must be an integer")
					
parser.add_argument("-tpn", "--threadspernode", dest="threads_per_node", metavar="THREADSPERNODE", type=int,
					help="Number of threads per node used for simulation, must be an integer")

args = parser.parse_args()

if args.filename:
	filename = str(args.filename)
	print 'filename = ', filename
	
if args.cores:
	cores = int(args.cores)
	print 'Cores = ', cores
	
if args.nodes:
	nodes = int(args.nodes)
	print 'nodes = ', nodes
	
if args.total_threads:
	total_threads = int(args.total_threads)
	print 'total_threads = ', total_threads
	
if args.threads_per_node:
	threads_per_node = int(args.threads_per_node)
	print 'threads_per_node = ', threads_per_node
	
if not args.nodes:
	print 'Number of nodes not specified (use -n), assuming 1 node'
	nodes = 1
	
if not args.total_threads or args.threads_per_node:
	print 'Number of threads not given (use -t for total, -tpn for threads per node), assuming 40 threads per node'
	threads_per_node = 40
	total_threads = nodes * threads_per_node
	
if args.nodes and args.threads_per_node and args.total_threads:
	tpn = total_threads / nodes
	if tpn != threads_per_node:
		print 'WARNING:'
		print '\tGiven nodes (%i), total threads (%i), and threads per node (%i)' % (nodes, total_threads, threads_per_node) 
		print '\tTotal threads (%i) / nodes (%i) = %f' % (total_threads, nodes, (total_threads/nodes))
		print '\tThreads per node given as %i' % (threads_per_node)
		print '\tThreads per node set to %i, to override this please don\'t specify the threads per node'

# Open file and find the line 'turn intensity n_mp etc'
start_line = 0
turn = []
raw_time = []
raw_date = []
turn_time = []

with open(filename) as fp:
    for line in fp:		
		if start_line:
			# Record the data we need			
			turn.append(line.split()[0])
			raw_time.append(line.split()[-1])
			raw_date.append(line.split()[-2])
		# ~ if 'turn' and 'intensity' and 'n_mp' and 'gamma' and 'mean_x' and 'mean_xp' and 'mean_y' and 'mean_yp' and 'mean_z' in line:
		if 'execution time' in line:
			print 'found line:\n',line
			start_line = 1
		# ~ if not start_line:
			# ~ print line

i = 0
print 'turn ', turn[0], ', raw date ', raw_date[0], ', raw time ', raw_time[0]
print 'turn ', turn[-1], ', raw date ', raw_date[-1], ', raw time ', raw_time[-1]

# Calculate total time and time per turn; first, last, average etc
turn_time = calculate_time_steps(raw_time, raw_date)
tot_time = sum(turn_time)
average_turn_time = float(np.mean(turn_time))

print 'Simulation on %i threads:' % (total_threads)
print 'Total simulation time in seconds = %i' % (tot_time)
print 'Total simulation time in minutes = %f' % (float(tot_time)/60)
print 'Total simulation time in hours = %f' % (float(tot_time)/3600)
print 'Mean simulation time per turn in seconds = %i' % (average_turn_time)
