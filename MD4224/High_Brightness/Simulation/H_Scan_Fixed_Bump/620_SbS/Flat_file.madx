TITLE, "Flat file generation for PTC-PyORBIT";

/******************************************************************
 * MAD-X PS Optics
 **
 ** Injection energy with bump closure tune swing
 ** Haroon Rafique 02.07.19
 **
 ** Based on the work of:
 ** Alexander Huschauer  02/09/16
 ** Eugenio Senes
 ******************************************************************/

tune_x = 0.20;
tune_y = 0.24;

/***********************************************************************
 * INITIALIZATION
 * First we call the files describing the machine, in this case we use 
 * the CERN proton synchrotron (PS).
 **********************************************************************/
call, file="./Lattice/PS_new_injection_bump.ele";
call, file="./Lattice/PS_2013.aper";
call, file="./Lattice/PS_new_injection_bump.seq";
call, file="./Lattice/PS_new_injection_bump.str";
call, file="./Lattice/macros.ptc";

/***********************************************************************
 * RFV can be used to manually seet the RF cavity voltage.
 * This is overridden by a PTC RF table (called from PyORBIT).
 **********************************************************************/
RFV = 0.021;

/***********************************************************************
 * Create a MAD-X beam and tell MAD-X which accelerator lattice to use.
 **********************************************************************/
beam, particle=proton, pc=pc;
use, sequence=PS;

/***********************************************************************
 * Here we manually edit the sequence (lattice) to install a zero length
 * beam wire scanner at the start of region 64. We then save the new 
 * sequence to a file.
 **********************************************************************/
PR.BWSH65     :  MONITOR  , L = 0.0; 

seqedit, sequence=PS;
	flatten;
	install, element=PR.BWSH65, at=0.3, from=PS65$START;
	flatten;
endedit;

use, sequence=PS;

seqedit, sequence=PS;
	flatten;
	cycle , start=PR.BWSH65;
	flatten;
endedit;

save,file='./PS.seq';

use, sequence=PS;

value, pc, beam->pc, beam->energy;

/***********************************************************************
 * Low chroma setup
 **********************************************************************/
 
 /**********************************************************************
**                        Multipoles in MUs                           **
***********************************************************************/
pfki1f             =    -0.002562382254 ;
pfki2f             =      0.02189512262 ;
pfki3f             =       0.1160601827 ;

pfki1d             =     0.002381835717 ;
pfki2d             =     -0.02318695986 ;
pfki3d             =       -0.121350943 ;

/******************************************************************
* Polynomials obtained from measurements of non-linear chromaticity
*                on LHC flat bottom - 09.04.2018
 ******************************************************************/
!2nd dedree polynomial
!Qx=0.21 + 0.83801238423 x +  68.6013557004 x^2
!Qy=0.24 - 2.91974082086 x + 115.247493197 x^2

MQx0 :=  0.21;
MQx1 := 0.838012384227;
MQx2 := 68.6013557004;

MQy0 :=  0.24;
MQy1 := -2.91974082086;
MQy2 := 115.247493197;

/**************** low-energy quadrupoles from LSA ****************/
kf = -0.002 ;
kd =  0.0036 ;

/******************************************************************
* Polynomials obtained from measurements of non-linear chromaticity
*                on LHC flat bottom - 01.11.2018
 ******************************************************************/
!2nd dedree polynomial
!Qx = 0.21 + 0.77 x + 60.1 x^2
!Qy = 0.32 - 2.85 x + 10.5 x^2

MQx0 :=  0.21;
MQx1 := 0.77;
MQx2 := 60.1;

MQy0 :=  0.32;
MQy1 := -2.85;
MQy2 := 10.5;

kf = 0.;
kd = 0.;

/******************************************************************
 * Multipole matching
 ******************************************************************/
use, sequence=PS;
match,use_macro;
        vary,name=PFKI1F;
        vary,name=PFKI1D;
        vary,name=PFKI2F;
        vary,name=PFKI2D;
        vary,name=PFKI3F;
        vary,name=PFKI3D;
        use_macro,name=ptc_chrom_macro;
        constraint,expr= qx0= 1*MQx0;
        constraint,expr= qy0= 1*MQy0;
        constraint,expr= qx1= 1*MQx1;
        constraint,expr= qy1= 1*MQy1;
        constraint,expr= qx2= 2*MQx2;
        constraint,expr= qy2= 2*MQy2;
jacobian,calls=50000,bisec=3;
ENDMATCH;

value,PFKI1F,PFKI2F,PFKI3F;
value,PFKI1D,PFKI2D,PFKI3D;

Assign, echo=terminal;

value,qx0,qx1,qx2/2;
value,qy0,qy1,qy2/2;
 
/***********************************************************************
 * Next we use a ptc macro to match the tunes in the lattice to
 * desired values tune_x and tune_y.
 *
 * Using model=2, exact=true is recommended.
 **********************************************************************/
 
ptc_twiss_tune_macro_false_split: macro={
  ptc_create_universe;
  ptc_create_layout, time=true, model=2, exact=true, method=6, nst=3;
  ptc_twiss, closed_orbit, table = ptc_twiss, icase=56, no=2, summary_table=ptc_twiss_summary;
  qx0=table(ptc_twiss_summary,Q1);
  qy0=table(ptc_twiss_summary,Q2);
  xcomax0=table(ptc_twiss_summary,XCOMAX);
  value, qx0, qy0;
  ptc_end;
};

ptc_twiss_tune_macro_false_split_n(nnn): macro={
  ptc_create_universe;
  ptc_create_layout, time=true, model=2, exact=true, method=6, nst=3;
  ptc_twiss, closed_orbit, table = ptc_twiss, file = nnn.ptc, icase=56, no=2, summary_table=ptc_twiss_summary;
  qx0=table(ptc_twiss_summary,Q1);
  qy0=table(ptc_twiss_summary,Q2);
  xcomax0=table(ptc_twiss_summary,XCOMAX);
  value, qx0, qy0;
  ptc_end;
};

use, sequence=PS;
match, use_macro;
  vary,   name=iqf, step=1.0E-6 ;
  vary,   name=iqd, step=1.0E-6 ;
  USE_MACRO, name=ptc_twiss_tune_macro_false_split;
  CONSTRAINT, expr=  table(ptc_twiss_summary,Q1)= tune_x;
  CONSTRAINT, expr=  table(ptc_twiss_summary,Q2)= tune_y;
  JACOBIAN,calls=10000,bisec=3,TOLERANCE=1.0E-21;
ENDMATCH;
value, IQF, IQD;

/***********************************************************************
 * Next we use the PTC script resplit.ptc - this is used to split
 * defined elements (dipole, quadrupole, sextupole families etc) in
 * order to introduce space charge nodes inside their length. See the
 * file for further information. Then the flat file is generated and 
 * saved.
 **********************************************************************/
 
ptc_create_universe;
ptc_create_layout,time=true, model=2, exact=true, method=6, nst=3;
ptc_script, file="PTC/resplit.ptc";
ptc_script, file="PTC/print_flat_file.ptc";
select, flag=ptc_twiss, clear; 
select, flag=ptc_twiss, column=name, s, betx, px, bety, py, disp3, disp3p, disp1, disp1p, x, y;
ptc_twiss, icase=5, no=4, deltap_dependency, closed_orbit, file, table=ptc_twiss;
ptc_end;

/***********************************************************************
 * Output a MAD-X TFS table for use with the tunespread calculator.
 **********************************************************************/

select, flag=twiss, clear;
select, flag=twiss, column=NAME, KEYWORD, S, BETX, BETY, ALFX, ALFY, MUX, MUY, DX, DY, X, Y;
set,    format="12.6f";
twiss,  sequence=PS, file=madx_twiss.tfs, save;

madx_twiss_file_macro(nnn): macro={
	select, flag=twiss, clear;
	select, flag=twiss, column=NAME, KEYWORD, S, BETX, BETY, ALFX, ALFY, MUX, MUY, DX, DY, X, Y;
	set,    format="12.6f";
	twiss,  sequence=PS, file=nnn.tfs, save;
}

/***********************************************************************
 * Now create tables for magnet ramp
 **********************************************************************/
 
use, sequence=PS;

xmax := table(summ, xcomax);
Qx := table(summ, Q1);
Qy := table(summ, Q2);

BSW40 := BSW40_K0;
BSW42 := BSW42_K0;
BSW43 := BSW43_K0;
BSW44 := BSW44_K0;
BSStren : = BSS;

fudge = 5.0;

K2_S40 := -BSStren*(BSW40_K0/BSW42_K0)*fudge;
K2_S42 := -BSStren*(BSW42_K0/BSW42_K0)*fudge;
K2_S43 := -BSStren*(BSW43_K0/BSW42_K0)*fudge;
K2_S44 := -BSStren*(BSW44_K0/BSW42_K0)*fudge;

create, table=mytable, column=BSEXT_t, BSStren, BSW40, BSW42, BSW43, BSW44, xmax, xcomax0, Qx, Qy, Qx0, Qy0, K2_S40, K2_S42, K2_S43, K2_S44, BUMP_40;

create, table=TBSEXT40, column=BSEXT_t, BSW40, K2_S40;
create, table=TBSEXT42, column=BSEXT_t, BSW42, K2_S42;
create, table=TBSEXT43, column=BSEXT_t, BSW43, K2_S43;
create, table=TBSEXT44, column=BSEXT_t, BSW44, K2_S44;

/***********************************************************************
 * Read input table
 **********************************************************************/

readtable, file='MADX_Input/BSEXT_Bump_SBEND.tfs';
nrows = table(BSWTABLE, tablelength);
value, nrows;
row = 0;

/***********************************************************************
 * Iterate over steps from input table
 **********************************************************************/
EOPTION, ADD=false;
while(row<nrows){
!while(row<3){
	row = row + 1;
	iteration = 0;
	value, iteration;

	SETVARS, TABLE=BSWTABLE, ROW=row;

	option, warn;
	option, -info;

	! Set kicker strengths as errors (with sextupole component)
	! N.B. if 'use' command is used after these, errors will be erased

	SELECT,FLAG=ERROR,CLEAR;
	SELECT,FLAG=ERROR,PATTERN=PI.BSM40;
	EFCOMP, DKN:={BSW40,0,K2_S40}; 

	SELECT,FLAG=ERROR,CLEAR;
	SELECT,FLAG=ERROR,PATTERN=PI.BSM42;
	EFCOMP, DKN:={BSW42,0,K2_S42}; 

	SELECT,FLAG=ERROR,CLEAR;
	SELECT,FLAG=ERROR,PATTERN=PI.BSM43;
	EFCOMP, DKN:={BSW43,0,K2_S43}; 

	SELECT,FLAG=ERROR,CLEAR;
	SELECT,FLAG=ERROR,PATTERN=PI.BSM44;
	EFCOMP, DKN:={BSW44,0,K2_S44}; 

	!exec, ptc_twiss_tune_macro_false_split;
	exec, ptc_twiss_tune_macro_false_split_n($row);
	exec, madx_twiss_file_macro($row);
	
	fill, table=mytable;
	fill, table=TBSEXT40;
	fill, table=TBSEXT42;
	fill, table=TBSEXT43;
	fill, table=TBSEXT44;
};

!SELECT, FLAG = ERROR, FULL;
!ESAVE, FILE = errors.dat;

/***********************************************************************
 * Create plot of closed orbit and tunes
 **********************************************************************/

plot, table=mytable, haxis=BSEXT_t, vaxis=xmax;
plot, table=mytable, haxis=BSEXT_t, vaxis=xcomax0;
plot, table=mytable, haxis=BSEXT_t, vaxis=Qx0;
plot, table=mytable, haxis=BSEXT_t, vaxis=Qy0;
plot, table=mytable, haxis=BSEXT_t, vaxis=Qx;
plot, table=mytable, haxis=BSEXT_t, vaxis=Qy;
plot, table=mytable, haxis=BSEXT_t, vaxis=K2_S40, K2_S42, K2_S43;
plot, table=mytable, haxis=BSEXT_t, vaxis=K2_S44;
plot, table=mytable, haxis=BSEXT_t, vaxis=BSStren;
plot, table=mytable, haxis=BSEXT_t, vaxis=BSW40, BSW44;
plot, table=mytable, haxis=BSEXT_t, vaxis=BSW43, BSW42, BSW40;
plot, table=mytable, haxis=BSEXT_t, vaxis=BUMP_40;

/***********************************************************************
 * Write tables for magnet ramp
 **********************************************************************/
 
write, table=mytable, file='BSEXT_Out.tfs';
write, table=TPI.BSM40.1, file='PI.BSM40.1.tfs';
write, table=TBSEXT40, file='BSEXT40.tfs';
write, table=TBSEXT42, file='BSEXT42.tfs';
write, table=TBSEXT43, file='BSEXT43.tfs';
write, table=TBSEXT44, file='BSEXT44.tfs';
