#!/usr/bin/python
# Reads the output generated by PTC-PyORBIT when using Hannes Bartosik's
# output dictionary (outputs the time of each turn)

import matplotlib.pyplot as plt
# ~ from matplotlib.patches import Patch
# ~ from matplotlib.ticker import FormatStrFormatter
# ~ from matplotlib.lines import Line2D
import numpy as np
import scipy.io as sio 
import os
import sys

plt.rcParams['figure.figsize'] = [8.0, 6.0]
plt.rcParams['figure.dpi'] = 300
plt.rcParams['savefig.dpi'] = 300

plt.rcParams['font.size'] = 6
plt.rcParams['legend.fontsize'] = 'small'
# ~ plt.rcParams['figure.titlesize'] = 'medium'

plt.rcParams['lines.linewidth'] = 0.5


def convert_hh_mm_ss_to_seconds(raw_time):
	hour = int(raw_time.split(':')[0])
	minute = int(raw_time.split(':')[1])
	second = int(raw_time.split(':')[2])
	
	return int((hour*3600) + (minute*60) + (second))
	
def convert_seconds_to_hh_mm_ss(time_in_s):
	hours_remainder = (time_in_s % 3600)
	hours = (time_in_s- hours_remainder)/3600
	minutes_remainder = (hours_remainder % 60)
	minutes = (hours_remainder - minutes_remainder)/60
	seconds = minutes_remainder
	
	return str(str(hours)+':'+str(minutes)+':'+str(seconds))
	
def calculate_time_steps(raw_time, raw_date):
	
	if len(raw_time) != len(raw_date):
		print 'ERROR: Function calculate_time_steps: Length of raw time and raw date arrays are not equal. EXITING'
		sys.exit()
	
	start_time = raw_time[0]
	start_date = raw_date[0]
	start_time_seconds = convert_hh_mm_ss_to_seconds(start_time)
	turn_time_s=[]
	
	print '\n\tcalculate_time_steps: simulation started at %s %s\nwhich is %i seconds' % (start_date, start_time, start_time_seconds)
	
	for i in range(len(raw_time)-1):
		# Check that we haven't gone past midnight
		if i == 0:
			turn_time_s.append( int( convert_hh_mm_ss_to_seconds(raw_time[i+1]) - start_time_seconds ) )		
		elif i != len(raw_time):
			if raw_date[i+1] != raw_date[i]: # Changed days
				turn_time_s.append( int( (86400 - convert_hh_mm_ss_to_seconds(raw_time[i])) + convert_hh_mm_ss_to_seconds(raw_time[i+1]) ) )
			else:	# Haven't changed days
				turn_time_s.append( int( convert_hh_mm_ss_to_seconds(raw_time[i+1]) - convert_hh_mm_ss_to_seconds(raw_time[i]) ) )
	turn_time_s.append(int(0))	# Add extra value so that the list is the same length as the others
	return turn_time_s			
	
		

# Parse arguments from command line
from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("-f", "--file", dest="input_filename",
					help="Input filename, this is the raw output from a PTC-PyORBIT run, note that Hannes Bartosik's output dictionary is required, as well as a turn by turn output.update()", metavar="FILE")

parser.add_argument("-o", "--output", dest="output_filename",
					help="Input filename, this is the raw output from a PTC-PyORBIT run, note that Hannes Bartosik's output dictionary is required, as well as a turn by turn output.update()", metavar="FILE")

parser.add_argument("-c", "--cores", dest="cores", metavar="CORES", type=int,
					help="Number of CPU cores used for simulation, must be an integer")

parser.add_argument("-n", "--nodes", dest="nodes", metavar="NODES", type=int,
					help="Number of nodes used for simulation, must be an integer")
					
parser.add_argument("-t", "--threads", dest="total_threads", metavar="THREADS", type=int,
					help="Number of threads used for simulation, must be an integer")
					
parser.add_argument("-tpn", "--threadspernode", dest="threads_per_node", metavar="THREADSPERNODE", type=int,
					help="Number of threads per node used for simulation, must be an integer")

args = parser.parse_args()

output_flag = 0

if args.input_filename:
	input_filename = str(args.input_filename)
	print 'input_filename = ', input_filename

if not args.input_filename:
	print 'ERROR: Input filename not specified (use -f or --file). EXITING'
	sys.exit()
	
if args.output_filename:
	output_filename = str(args.output_filename)
	print 'output_filename = ', output_filename
	output_flag = 1

if not args.output_filename:
	print 'WARNING: Output filename not specified (use -o or --output). No output file will be created'
	
if args.cores: # obsolete at the moment
	cores = int(args.cores)
	print 'Cores = ', cores
	
if args.nodes:
	nodes = int(args.nodes)
	print 'nodes = ', nodes
	
if args.total_threads:
	total_threads = int(args.total_threads)
	print 'total_threads = ', total_threads
	
if args.threads_per_node:
	threads_per_node = int(args.threads_per_node)
	print 'threads_per_node = ', threads_per_node
	
if not args.nodes:
	print 'Number of nodes not specified (use -n), assuming 1 node'
	nodes = 1
	
if 'threads_per_node' not in locals():
	print 'Number of threads per node not given (use -tpn), looking for total threads'
# ~ elif not args.total_threads:

if 'total_threads' or 'threads_per_node' not in locals():
	print 'Number of threads not given (use -t for total, -tpn for threads per node), assuming 40 threads per node'
	threads_per_node = 40
	total_threads = nodes * threads_per_node
		
if args.nodes and args.threads_per_node and args.total_threads:
	tpn = total_threads / nodes
	if tpn != threads_per_node:
		print 'WARNING:'
		print '\tGiven nodes (%i), total threads (%i), and threads per node (%i)' % (nodes, total_threads, threads_per_node) 
		print '\tTotal threads (%i) / nodes (%i) = %f' % (total_threads, nodes, (total_threads/nodes))
		print '\tThreads per node given as %i' % (threads_per_node)
		print '\tThreads per node set to %i, to override this please don\'t specify the threads per node'

# READ OUTPUT
input_file = 'output.mat'
particles = dict()
sio.loadmat(input_file, mdict=particles)

# Parameters
# ~ output.addParameter('turn', lambda: turn)
# ~ output.addParameter('intensity', lambda: bunchtwissanalysis.getGlobalMacrosize())
# ~ output.addParameter('n_mp', lambda: bunchtwissanalysis.getGlobalCount())
# ~ output.addParameter('gamma', lambda: bunch.getSyncParticle().gamma())
# ~ output.addParameter('mean_x', lambda: bunchtwissanalysis.getAverage(0))
# ~ output.addParameter('mean_xp', lambda: bunchtwissanalysis.getAverage(1))
# ~ output.addParameter('mean_y', lambda: bunchtwissanalysis.getAverage(2))
# ~ output.addParameter('mean_yp', lambda: bunchtwissanalysis.getAverage(3))
# ~ output.addParameter('mean_z', lambda: bunchtwissanalysis.getAverage(4))
# ~ output.addParameter('mean_dE', lambda: bunchtwissanalysis.getAverage(5))
# ~ output.addParameter('epsn_x', lambda: bunchtwissanalysis.getEmittanceNormalized(0))
# ~ output.addParameter('epsn_y', lambda: bunchtwissanalysis.getEmittanceNormalized(1))
# ~ output.addParameter('eps_z', lambda: get_eps_z(bunch, bunchtwissanalysis))
# ~ output.addParameter('bunchlength', lambda: get_bunch_length(bunch, bunchtwissanalysis))
# ~ output.addParameter('dpp_rms', lambda: get_dpp(bunch, bunchtwissanalysis))

fig1=plt.figure(figsize=(4,9))
fig1.subplots_adjust(wspace=0.1, hspace=0.3, left=0.1, right=0.99, top=0.9, bottom=0.1)

# Turn vs turn_duration
ax1 = fig1.add_subplot(211) 
ax1.plot(particles['turn'][0], particles['turn_duration'][0], 'g');
ax1.set_xlabel('Turn [-]');
ax1.set_ylabel('Time for each turn [s]');
ax1.set_title('PS Injection HPC-Batch test: N = 5E3, 16x16x16, turn duration');
ax1.grid(True);

# Turn vs cumulative_time
ax2 = fig1.add_subplot(212)
ax2.plot(particles['turn'][0], particles['cumulative_time'][0], 'g');
ax2.set_xlabel('Turn [-]');
ax2.set_ylabel('Cumulative time [s]');
ax2.set_title('PS Injection HPC-Batch test: N = 5E3, 16x16x16, cumulative time');
ax2.grid(True);

fig1.savefig('Cumulative_and_Turn_Time.png');
